Напишите функцию
int run(const char *cmd, const char *input, char **poutput, char **perror, int timeout);
Функция запускает на выполнение в отдельном процессе команду cmd
и дожидается ее завершения. На стандартный поток ввода запущенной программе
по неименованному каналу передается строка input. Стандартный поток
вывода запущенной программы перенаправляется в канал к отцу, стандартный поток ошибок перенаправляется
в другой канал к отцу.

Программу запускать с помощью execlp.
Если при выполнении какого-либо системного вызова в отце (создание канала, создание процесса и т. д.)
произошла ошибка, функция должна вернуть -1. В случае, если ошибка системного вызова в отце произошла уже
после создания нового процесса, функция все равно возвращает -1, а созданный процесс должен быть
завершен посылкой ему сигнала SIGKILL.
Если указанную команду запустить не удалось, функция должна вернуть 1.
Если созданный процесс завершился из-за сигнала, необходимо вернуть
номер этого сигнала, к которому прибавлено 1024. В противном случае
необходимо вернуть код завершения созданного процесса.
В любом случае, только значение 0 может обозначать нормальное выполнение
созданного процесса.
Ошибку записи в канал EPIPE обрабатывайте, закрывая запись в канал. Эта ошибка не приводит
к ошибочному завершению функции run.
По указателю poutput записывается указатель на строку, в которую считан вывод
запущенной программы на стандартный поток вывода. По указателю perror
записывается указатель на строку, в которую считан вывод запущенной программы на
стандартный поток ошибок. Предполагайте, что в выводе не встречается нулевой байт.
Если поток вывода или поток ошибок пуст, то записывайте указатель на строку длины 0.
Указатели poutput и perror должны модифицироваться только если функция run
завершается не из-за ошибки выполнения самой функции (то есть если возвращается не -1).
В противном случае эти указатели не должны изменяться.
Память будет освобождаться с помощью free.
Параметр timeout - это максимальное астрономическое время работы программы в миллисекундах (ms).
Если программа не завершилась за указанное время, процесс завершается посылкой ему сигнала SIGKILL, затем родитель дожидается его завершения и возвращает результат в соответствии с кодом завершения сына.
Если timeout равен 0, ограничение времени для программы не устанавливается.
Поведение функции при timeout < 0 не определено.
Когда функция run завершает работу ни при каких условиях
в списке процессов не должен оставаться непосредственно созданный этой функцией процесс.
Для контроля за выполнением процесса используйте signalfd, timerfd и epoll.